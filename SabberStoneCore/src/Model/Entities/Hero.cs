#region copyright
// SabberStone, Hearthstone Simulator in C# .NET Core
// Copyright (C) 2017-2019 SabberStone Team, darkfriend77 & rnilva
//
// SabberStone is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as
// published by the Free Software Foundation, either version 3 of the
// License.
// SabberStone is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
#endregion
using System.Collections.Generic;
using System.Collections.Specialized;
using System.Linq;
using System.Text;
using SabberStoneCore.Auras;
using SabberStoneCore.Enums;
using SabberStoneCore.HearthVector;

namespace SabberStoneCore.Model.Entities
{
	/// <summary>
	/// The entity representing the player.
	/// </summary>
	/// <seealso cref="Character" />
	/// <autogeneratedoc />
	public partial class Hero : Character
	{
		public override string Prefix()
		{
			return Zone?.Type == Enums.Zone.DECK || Zone?.Type == Enums.Zone.HAND
				? base.Prefix() : "Hero.";
		}

		public override OrderedDictionary Vector()
		{
			OrderedDictionary v = base.Vector();

			//if (Auras.Count > 0)
			for (int i = 0; i < Auras.Count; ++i)
				v.AddRange(Auras[i].Vector(), Prefix());

			//else
			//	v.AddRange(Aura.NullVector, Prefix);

			v.Add($"{Prefix()}DamageTakenThisTurn", DamageTakenThisTurn);
			v.Add($"{Prefix()}EquippedWeapon", EquippedWeapon != 0 ? Controller.Game.IdEntityDic[EquippedWeapon].Card.AssetId : 0);
			v.Add($"{Prefix()}ExtraAttacksThisTurn", ExtraAttacksThisTurn);
			v.Add($"{Prefix()}Fatigue", Fatigue);
			v.AddRange(HeroPower.Vector(), Prefix());
			v.Add($"{Prefix()}HeroPowerDamage", HeroPowerDamage);
			if (Weapon != null)
				v.AddRange(Weapon.Vector(), Prefix());
			//v.AddRange(Weapon != null ? Weapon.Vector : Weapon.NullVector, Prefix);

			return v;
		}

		public static new OrderedDictionary NullVector
		{
			get
			{
				string prefix = "NullHero.";
				OrderedDictionary v = Character.NullVector;

				v.AddRange(Aura.NullVector, prefix);
				v.Add($"{prefix}DamageTakenThisTurn", 0);
				v.Add($"{prefix}EquippedWeapon", 0);
				v.Add($"{prefix}ExtraAttacksThisTurn", 0);
				v.Add($"{prefix}Fatigue", 0);
				v.AddRange(HeroPower.NullVector, "NullHero.");
				v.Add($"{prefix}HeroPowerDamage", 0);
				v.AddRange(Weapon.NullVector, "NullHero.");

				return v;
			}
		}

		/// <summary>Gets or sets the hero power entity.</summary>
		/// <value><see cref="Entities.HeroPower"/></value>
		public HeroPower HeroPower { get; set; }

		/// <summary>Gets or sets the weapon entity equipped on the Hero.</summary>
		/// <value><see cref="Entities.Weapon"/></value>
		public Weapon Weapon { get; set; }

		public List<Aura> Auras { get; }

		/// <summary>Initializes a new instance of the <see cref="Hero"/> class.</summary>
		/// <param name="controller">Owner of the character; not specifically limited to players.</param>
		/// <param name="card">The card which this character embodies.</param>
		/// <param name="tags">Properties of this entity.</param>
		/// <autogeneratedoc />
		public Hero(in Controller controller, in Card card, in IDictionary<GameTag, int> tags, in int id = -1)
			: base(in controller, in card, in tags, in id)
		{
			Auras = new List<Aura>();
			Game.Log(LogLevel.VERBOSE, BlockType.PLAY, "Hero", !Game.Logging? "":$"{card.Name} ({card.Class}) was created.");
		}

		/// <summary>
		/// A copy constructor.
		/// </summary>
		/// <param name="controller">The target <see cref="T:SabberStoneCore.Model.Entities.Controller" /> instance.</param>
		/// <param name="hero">The source <see cref="T:SabberStoneCore.Model.Entities.Hero" />.</param>
		private Hero(in Controller controller, Hero hero) : base(in controller, hero)
		{
			Auras = new List<Aura>(hero.Auras.Count);
			DamageTakenThisTurn = hero.DamageTakenThisTurn;
		}

#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		public override int AttackDamage => base.AttackDamage + (Game.CurrentPlayer != Controller ? 0 : Weapon?.AttackDamage ?? 0);

		public int TotalAttackDamage => AttackDamage/* + (Weapon?.AttackDamage ?? 0)*/;

		public override bool CanAttack
			=> AttackDamage > 0
			   && (!IsExhausted || (_extraAttacksThisTurn > 0 && _extraAttacksThisTurn >= _numAttackThisTurn))
			   && !IsFrozen
			   && HasAnyValidAttackTargets;

		public override bool HasWindfury
		{
			get => Weapon != null && Weapon.IsWindfury;
			set => Weapon.IsWindfury = value;
		}

		public override bool HasLifeSteal => Weapon?.HasLifeSteal ?? false;

		public override bool IsImmune
		{
			get => (AuraEffects?.Immune > 0) || base.IsImmune;
			set => base.IsImmune = value;
		}

		public override bool HasOverkill => Weapon?.HasOverkill ?? false;

		public void AddWeapon(Weapon weapon)
		{
			RemoveWeapon();
			weapon.OrderOfPlay = Game.NextOop;
			Weapon = weapon;
			Weapon[GameTag.ZONE] = (int)Enums.Zone.PLAY;
			Weapon[GameTag.ZONE_POSITION] = 0;
			EquippedWeapon = weapon.Id;
			if (weapon.IsWindfury && IsExhausted && NumAttacksThisTurn == 1)
				IsExhausted = false;

			Game.TriggerManager.OnEquipWeaponTrigger(weapon);
		}

		/// <summary>
		/// Removes the equipped weapon to the graveyard. This triggers deathrattle events on the weapon.
		/// </summary>
		public void RemoveWeapon()
		{
			if (Weapon == null)
				return;

			if (Weapon.HasDeathrattle)
				Weapon.ActivateTask(PowerActivation.DEATHRATTLE);

			Game.TriggerManager.OnDeathTrigger(Weapon);

			Game.Log(LogLevel.INFO, BlockType.PLAY, "Hero", !Game.Logging? "":$"Butcher's knife incoming to graveyard, say 'gugus' to {Weapon}");
			Controller.GraveyardZone.Add(Weapon);

			ClearWeapon();
		}

		/// <summary>
		/// Clears weapon information on Hero.
		/// </summary>
		public void ClearWeapon()
		{
			Weapon.ActivatedTrigger?.Remove();
			Weapon.OngoingEffect?.Remove();
			if (Weapon.AppliedEnchantments != null && Weapon[GameTag.KEEP_ENCHANTMENTS] != 1)
				for (int i = Weapon.AppliedEnchantments.Count - 1; i >= 0; i--)
					Weapon.AppliedEnchantments[i].Remove();
			Weapon = null;
			EquippedWeapon = 0;
		}

		public override IPlayable Clone(in Controller controller)
		{
			return new Hero(in controller, this);
		}

		public string FullPrint()
		{
			var str = new StringBuilder();
			string wStr = Weapon != null ? $"WEAPON: [{Weapon.Card.Cost}]{Weapon.Card.Name} -- [{Weapon.AttackDamage}/{Weapon.Durability}]" : "NO WEAPON";
			str.Append($"{Card.Name} | MANA:{Controller.RemainingMana}/{Controller.BaseMana} | ATK:{AttackDamage} | AR:{Armor} | HP:{Health} | {wStr} | SP+:{Controller.CurrentSpellPower}");
			//str.Append($"[ENCH {OldEnchants.Count}]");
			//str.Append($"[TRIG {Triggers.Count}]");
			return str.ToString();
		}

#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	}

	public partial class Hero
	{
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

		//public int SpellPowerDamage => this[GameTag.CURRENT_SPELLPOWER];

		public int EquippedWeapon
		{
			get { return this[GameTag.WEAPON]; }
			set { this[GameTag.WEAPON] = value; }
		}

		public int HeroPowerDamage
		{
			get { return this[GameTag.HEROPOWER_DAMAGE]; }
			set { this[GameTag.HEROPOWER_DAMAGE] = value; }
		}

		public int Fatigue
		{
			get { return this[GameTag.FATIGUE]; }
			set { this[GameTag.FATIGUE] = value; }
		}

		public int DamageTakenThisTurn { get; set; }

		public override bool CantAttackHeroes
		{
			get
			{
				if (AuraEffects?.CantAttackHeroes ?? false)
					return true;

				return base.CantAttackHeroes;
			}
			set => base.CantAttackHeroes = value;
		}

		private int _extraAttacksThisTurn;

		public int ExtraAttacksThisTurn
		{
			get => _extraAttacksThisTurn;
			set
			{
				_extraAttacksThisTurn = value;
				if (_history)
					this[GameTag.EXTRA_ATTACKS_THIS_TURN] = value;
			}
		}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
	}
}
